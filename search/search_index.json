{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jet1090","text":"<p>Tip</p> <p>See the navigation links in the header or side-bar.</p> <p>Click  (top left) on mobile.</p> <p>jet1090 is a powerful tool for aviation enthusiasts , researchers , and developers , which offers a reliable, efficient, and flexible solution for real-time ADS-B and Mode S data decoding and analysis.</p> <p>jet1090 aims to be an essential open-source tool in the tangram suite for tracking live flights , analyzing real-time aviation traffic patterns , and creating polished visualizations  with minimal code.</p> <p></p> <p>Built on the  rs1090 library (which also provides  Python and  WASM bindings), jet1090 offers:</p> <ul> <li>A lightweight, standalone executable, ideal for low-resource devices;</li> <li>High-performance and comprehensive ADS-B and Mode S decoding,   optimized for real-time processing through Rust\u2019s speed and efficiency;</li> <li>Input options: compatible with Beast format, RTL-SDR dongles, and the SeRo gRPC API   (contributions for more input formats is welcome);</li> <li>Output options: files (JSON), a text user interface, REST, WebSocket, Redis pub/sub, etc.   (contributions for more output formats is welcome);</li> <li>Filtering capabilities common to all output options   include Downlink Format (DF), receiver identifier (custom), and ICAO24 aircraft transponder codes.</li> </ul>"},{"location":"#user-guide","title":"User guide","text":"<ul> <li>Installation</li> <li>Sources of data</li> <li>Serving real-time data</li> <li>Configuration options</li> <li>Contribute to the project</li> </ul> <p>Warning</p> <p>These pages only document the jet1090 tool.</p> <p>Follow the links for the documentation of the  Rust library rs1090 with  Python and  WebAssembly bindings.</p>"},{"location":"#existing-tools","title":"Existing tools","text":"<ul> <li> <p><code>dump1090</code> has played an important role in the popularization of crowdsourcing ADS-B data reception. Originally developed by @antirez on GitHub, the most up-to-date fork is maintained by @mutability for FlightAware. This fork supports many low-cost hardware devices, making ADS-B data reception accessible to a wider audience. Recent forks of <code>dump1090</code> now include features such as demodulation of messages at 2.4 MHz or 8 MHz. Another noteworthy development is <code>readsb</code>, a newer fork of <code>dump1090</code> that offers enhanced networking functionality and an aggregator backend.</p> </li> <li> <p><code>pyModeS</code> is a Python library designed for decoding Mode S and ADS-B messages from aircraft. It provides a flexible and user-friendly interface for working with raw data, making it an excellent tool for enthusiasts and researchers in the field of aviation tracking. pyModeS decodes messages in Python (with some compiled Cython extensions as performance can be a bottleneck) provided some knowledge by the user. The author of pyModeS also offers an online book, to document the decoding of ADS-B and Mode S data.</p> </li> </ul> <p>Online services such as FlightRadar24 provide an outstanding coverage of ADS-B data, but the data is proprietary. Displayed metadata information is of excellent quality, but trajectory information is filtered following an opaque process. The OpenSky Network offers unfiltered data with academic-friendly terms of use but decoded data is incomplete.</p>"},{"location":"#initial-motivation","title":"Initial motivation","text":"<p>The development of the rs1090 library and the jet1090 tool started because of limitations of the two previous tools:</p> <ul> <li><code>dump1090</code> is a very efficient community-supported decoding tool whose main objective is trajectory visualization: decoding capabilities are incomplete, and output interfaces are limited. It is implemented in C.</li> <li><code>pyModeS</code> offers a comprehensive decoding framework, easy to extend. It is based on a \u201cdecode what you need\u201d approach, so previous knowledge about the data format is required. Initial decoding prototypes for real-time streams of data are very CPU and RAM consuming, and do not scale well. Multi-feed is not supported. It is implemented in Python.</li> </ul>"},{"location":"#design-choices-for-jet1090","title":"Design choices for jet1090","text":"<p><code>rs1090</code> and <code>jet1090</code> are coded in  Rust, for performance, code safety, and modularity.</p> <ul> <li><code>rs1090</code> ports all the decoding knowledge of   <code>pyModeS</code> in Rust. It is implemented following a \u201cdecode it all\u201d approach.</li> <li><code>jet1090</code> is the executable program which connects data sources, merges data feeds, deduplicates messages, and serves decoded data in real-time.</li> </ul> <p>By design, the language and standard low-level libraries (e.g., <code>trino</code> for the asynchronous programming, or <code>serde</code> for the serialization) makes it easy to access data in real-time for those who don't know Rust and don't care about how things work. All the data is decoded, serialized into a flattened JSON representation, and meta-information about the source of data is attached.</p> <code>dump1090</code> <code>pyModeS</code> <code>jet1090</code> Programming language Extensive decoding Multi-feed SDR RTL-SDR only RTL-SDR only Real-time feed-out Beast format <p>Example</p> <p>In the following example, the message <code>8d4400eb58c7d45c48e257428292</code> has been received by two different receivers within 200+ms. Timestamping information based on GNSS clocks has been attached, as well as signal strength. All the information present in the message is decoded and flattened in the JSON entry; latitude and longitude values are decoded based on the history of received BDS 0,5 messages.</p> <pre><code>{\n  \"timestamp\": 1734990395.4640563,\n  \"frame\": \"8d4400eb58c7d45c48e257428292\",\n  \"df\": \"17\",\n  \"icao24\": \"4400eb\",\n  \"bds\": \"05\",\n  \"tc\": 11,\n  \"NUCp\": 7,\n  \"NICb\": 0,\n  \"altitude\": 38925,\n  \"source\": \"barometric\",\n  \"parity\": \"odd\",\n  \"lat_cpr\": 11812,\n  \"lon_cpr\": 57943,\n  \"latitude\": 49.36343435513771,\n  \"longitude\": 4.188031648334704,\n  \"metadata\": [\n    {\n      \"system_timestamp\": 1734990395.4640563,\n      \"gnss_timestamp\": 1734990395.4026532,\n      \"nanoseconds\": 84176392945664,\n      \"rssi\": -12.567779,\n      \"serial\": 9467850719808063263\n    },\n    {\n      \"system_timestamp\": 1734990395.6401641,\n      \"gnss_timestamp\": 1734990395.539131,\n      \"nanoseconds\": 84176529423429,\n      \"rssi\": -24.048405,\n      \"serial\": 4075562207768597288\n    }\n  ]\n}\n</code></pre>"},{"location":"config/","title":"Configuration options","text":"<p>All the options passed to the executable and visible in the help can also be configured as default in a configuration file.</p> <pre><code>jet1090 --help\n</code></pre> <p>By default, the configuration file is located in:</p> <ul> <li><code>$HOME/.config/jet1090/config.toml</code> for Linux systems;</li> <li><code>$HOME/Library/Application\\ Support/jet1090/config.toml</code> for MacOS systems;</li> <li><code>%HOME%\\AppData\\Roaming\\jet1090\\config.toml</code> for Windows systems</li> </ul> <p>Support for <code>XDG_CONFIG_HOME</code></p> <p>If the <code>XDG_CONFIG_HOME</code> variable is set, it takes precedence over the folders detailed above.</p> <p>This means you can set this variable and use the <code>$HOME/.config</code> folders in MacOS systems as well.</p> <p>Tip</p> <ul> <li>You can also set a different configuration file in the <code>JET1090_CONFIG</code> environment variable.</li> <li>You can also set that variable in the <code>.env</code> (dotenv) file located in the current folder and <code>jet1090</code> will look into it.</li> </ul> <p>If you have several scenarios requiring different configurations files, this option may be where to look at.</p>"},{"location":"config/#general-settings","title":"General settings","text":"<p>If you set a configuration file, some parameters must be always present:</p> <pre><code>interactive = false      # display a table view\nverbose = false          # display decoded messages in the terminal\nprevent_sleep = false    # force the laptop not to enter sleep mode (useful when lid is closed)\nupdate_position = false  # auto-update the reference position (useful when on a moving aircraft)\n</code></pre> <p>Other parameters are optional:</p> <pre><code>deduplication = 800        # buffer interval for deduplication, in milliseconds\nhistory_expire = 10        # in minutes\nlog_file = \"-\"             # use together with RUSTLOG environment variable\noutput = \"~/output.jsonl\"  # the ~ (tilde) character is automatically expanded\nredis_url = \"redis://localhost:6379\"\nserve_port = 8080          # for the REST API\n</code></pre>"},{"location":"config/#sources","title":"Sources","text":"<p>Warning</p> <p>If you do not want to set any source in the configuration file, you must specify an empty list:</p> <pre><code>sources = []\n</code></pre> <p>Otherwise, do not include that line, and set as many sources as you need with the <code>[[sources]]</code> header.</p>"},{"location":"config/#rtl-sdr","title":"RTL-SDR","text":"<p>The following entry is equivalent to <code>rtlsdr://serial=00000001@LFBO</code> except that it sets an alias <code>rtl-sdr</code>:</p> <pre><code>[[sources]]\nname = \"rtl-sdr\"\nrtlsdr = \"serial=00000001\"\nairport = \"LFBO\"\n</code></pre> <p>The <code>airport</code> parameter replaces the <code>latitude</code> and <code>longitude</code> parameter if they are not present.</p>"},{"location":"config/#beast-format","title":"Beast format","text":"<p>External sources can be configured with the <code>tcp</code>, <code>udp</code> or <code>websocket</code> fields.</p> <pre><code>[[sources]]\nname = \"Toulouse\"\ntcp = \"123.45.67.89:10003\"\nlatitude = 43.5993189\nlongitude = 1.4362472\n</code></pre> <p>For the <code>websocket</code> you must specify the <code>ws://</code> prefix:</p> <pre><code>[[sources]]\nwebsocket = \"ws://123.45.67.89:8765/zurich\"\nairport = \"LSZH\"\n</code></pre> <p>Reference positions</p> <p>When in a hurry, an airport code is enough to decode surface messages (otherwise, only <code>lat_cpr</code> and <code>lon_cpr</code> are provided). It may be useful to fill in precise values for <code>latitude</code>, <code>longitude</code> and <code>altitude</code> for multilateration applications.</p> <p>Different names for different sources</p> <p>The <code>name</code> entry is not mandatory but it is helpful to help recognize different sources in the output format. However, internally, an hashed version of the address is used to uniquely identify sources.</p>"},{"location":"config/#sero-systems","title":"SeRo Systems","text":"<p>You may input here your SeRo Systems token in order to receive your data. Extra filters are also available in order to limit the network bandwidth.</p> <pre><code>[[sources]]\nsero.token = \"\"\nsero.df_filter = [17, 18, 20, 21]  # (default: no filter)\n# sero.aircraft_filter = []  # list of integer values corresponding to icao24 addresses (default: no filter)\n</code></pre>"},{"location":"contribute/","title":"Contribute to the project","text":"<p><code>jet1090</code> is an open-source project distributed under the MIT license.</p> <p>Contributions in any form are welcome, but please follow these minimal guidelines:</p> <ul> <li>for all contributions, open a pull request on GitHub</li> <li>if you fix a typo in the code or in the documentation, thank you!</li> <li>if you fix a bug with your contribution, please file an issue first and describe the problem</li> <li>if you want to implement a new functionality, or improve an existing one, briefly explain the motivation in the pull request.</li> </ul> <p>New functionalities</p> <ul> <li>In particular, any functionality supported by an existing tool but not by <code>jet1090</code> is welcome.</li> <li>I have a particular interest for supporting more SDR devices, but I only own the cheap RTL-SDR ones.</li> </ul>"},{"location":"install/","title":"Installation instructions","text":"<p>The latest release and installation instructions are published on GitHub Releases.</p> <p>Current version is v0.4.1</p>"},{"location":"install/#install-prebuilt-binaries","title":"Install prebuilt binaries","text":"Shell scriptPowershell (Windows)Homebrew <p>This script requires that you install the SoapySDR dependencies.</p> <pre><code>curl --proto '=https' --tlsv1.2 -LsSf https://github.com/xoolive/rs1090/releases/download/v0.4.1/jet1090-installer.sh | sh\n</code></pre> <p>Update to next release with:</p> <pre><code>jet1090-update\n</code></pre> <p>This script requires that you install the SoapySDR dependencies.</p> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://github.com/xoolive/rs1090/releases/download/v0.4.1/jet1090-installer.ps1 | iex\"\n</code></pre> <p>Update to next release with:</p> <pre><code>jet1090-update\n</code></pre> <p>SoapySDR dependencies are automatically installed.</p> <pre><code>brew install xoolive/homebrew/jet1090\n</code></pre> <p>Update to next release with:</p> <pre><code>brew upgrade\n</code></pre>"},{"location":"install/#dependencies","title":"Dependencies","text":"<p>The prebuilt binaries are compiled with all features activated. In particular, support for RTL-SDR is provided through SoapySDR which may require extra dependencies.</p> UbuntuHomebrewWindows <pre><code>sudo apt install libsoapysdr-dev soapysdr-module-rtlsdr\n</code></pre> <p>Dependencies are automatically installed if you install <code>jet1090</code> through Homebrew. You have to run the command to build the project from source.</p> <pre><code>brew install soapysdr soapyrtlsdr\n</code></pre> <ul> <li>Install PothosSDR. If you don't have admin rights, you may unzip the archive and add the <code>bin/</code> folder to your <code>PATH</code> variable.</li> <li>You will also need Zadig to install the drivers for your RTL-SDR dongle (admin rights necessary).</li> </ul>"},{"location":"install/#build-from-source","title":"Build from source","text":"cargonix <p>You will need:</p> <ul> <li>the SoapySDR dependencies to compile with the <code>rtlsdr</code> feature.</li> <li>a protobuf compiler to compile with the <code>sero</code> feature.</li> </ul> <pre><code>cargo install --all-features jet1090\n</code></pre> <p>Note that a protobuf compiler is also necessary to compile the project with the <code>sero</code> feature:</p> UbuntuHomebrewWindows <pre><code>sudo apt install protobuf-compiler\n</code></pre> <pre><code>brew install protobuf\n</code></pre> <ul> <li>Install Protobuf compiler</li> </ul> <p>Nix takes care of its own dependencies. The script has been tested for Linux and MacOS.</p> <pre><code>git clone https://github.com/xoolive/rs1090\nnix profile install\n</code></pre>"},{"location":"install/#shell-completion","title":"Shell completion","text":"BashZshfishPowershellNushellElvish <p>Add the following to the end of your <code>~/.bashrc</code>:</p> <pre><code>eval \"$(jet1090 --completion bash)\"\n</code></pre> <p>Add the following to the end of your <code>~/.zshrc</code>:</p> <pre><code>eval \"$(jet1090 --completion zsh)\"\n</code></pre> <p>Add the following to the end of <code>~/.config/fish/config.fish</code>:</p> <pre><code>jet1090 --completion fish | source\n</code></pre> <p>Add the following to the end of <code>Microsoft.PowerShell_profile.ps1</code>. You can check the location of this file by querying the <code>$PROFILE</code> variable in PowerShell. Typically the path is<code>~\\Documents\\PowerShell\\Microsoft.PowerShell_profile.ps1</code> or <code>~/.config/powershell/Microsoft.PowerShell_profile.ps1</code> on -Nix.</p> <pre><code>(&amp; jet1090 --completion powershell) | Out-String | Invoke-Expression\n</code></pre> <p>Add the following to the end of your Nushell env file (find it by running <code>$nu.env-path</code>):</p> <pre><code>mkdir -p ~/.config/jet1090\njet1090 --completion nushell | save -f ~/.config/jet1090/completions.nu\n</code></pre> <p>then, add the following to the end of your Nushell configuration (find it by running <code>$nu.config-path</code>):</p> <pre><code>use ~/.config/jet1090/completions.nu *\n</code></pre> <p>Add the following to the end of <code>~/.elvish/rc.elv</code>:</p> <pre><code>eval (jet1090 --completion elvish | slurp)\n</code></pre>"},{"location":"output/","title":"Serving real-time decoded data","text":""},{"location":"output/#output-in-the-terminal","title":"Output in the terminal","text":"<ul> <li>The <code>--verbose</code> option dumps JSON entries to the terminal as messages are received.</li> <li>The <code>--interactive</code> option is similar to the <code>dump1090 --interactive</code> and provides a table view of the visible aircraft.</li> </ul> <p>Both options are incompatible and <code>--interactive</code> has the priority.</p> <p>In the table view, aircraft can be sorted by:</p> key <code>.</code> number of messages (<code>count</code>), default <code>A</code> altitude <code>C</code> callsign <code>F</code> first timestamp <code>L</code> last timestamp <code>V</code> vertical rate <code>-</code> ascending/descending order"},{"location":"output/#output-as-a-json-file","title":"Output as a JSON file","text":"<p>The <code>-o</code> or <code>--output</code> option enables the dumping of decoded messages to a file in the JSON line format.</p> <p>That format is easily accessible from several libraries across programming languages:</p> Pandas (Python)Polars (Python)Polars (Rust)JavaScriptR <pre><code>import pandas as pd\n\ndf = pd.read_json(\"output.jsonl\", lines=True)\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.read_ndjson(\"output.jsonl\")\n</code></pre> <p>You will need the <code>lazy</code> and <code>ndjson</code> (new line delimited JSON) features:</p> <pre><code>[dependencies]\npolars = { version = \"0.34\", features = [\"lazy\", \"ndjson\"] }\n</code></pre> <pre><code>use polars::prelude::*;\n\nlet df = LazyFrame::scan_ndjson(\"output.jsonl\", ScanArgsNdJson::default())?\n    .collect()?;\n</code></pre> <pre><code>data = fetch(\"output.jsonl\")\n  .then(response =&gt; response.text())\n  .then(text =&gt; text.split(\"\\n\").filter(line =&gt; line.trim() !== \"\").map(JSON.parse));\n</code></pre> <pre><code>library(ndjson)\n\ndf &lt;- ndjson::stream_in(\"output.jsonl\")\n</code></pre>"},{"location":"output/#rest-api","title":"REST API","text":"<p>If a <code>--serve-port</code> option is set, a REST API is set on <code>0.0.0.0</code> on the port of your choice.</p> <p>The following endpoint are provided:</p> <ul> <li><code>/</code>: returns a list of all visible <code>icao24</code> identifiers</li> <li><code>/all</code>: returns a list of all state vectors (the last valid field for each aircraft)</li> <li><code>/track?icao24=xxx</code>: returns a list of all received messages for a given aircraft.</li> </ul> <p>Warning</p> <p>By default, all the history remains accessible until the program exits but this behaviour can drain your RAM memory quickly if you see many aircraft. You can use the <code>--history-expire</code> parameter to limit the history to a number of minutes before the current time.</p> <p>You can also completely deactivate the storing of messages with the <code>--history-expire 0</code> option.</p>"},{"location":"output/#websocket","title":"WebSocket","text":"<p>(not yet supported)</p>"},{"location":"output/#redis-pubsub","title":"Redis pub/sub","text":"<p>If the <code>--redis-url</code> is set, all messages are sent to the Redis pub/sub instance.</p> <p>The default topic is <code>jet1090</code> but it can be overriden with the <code>--redis-topic</code> option.</p> <p>You may run a Redis server as a Docker or podman instance:</p> Dockerpodman <pre><code>docker run -d --rm --name redis -p 6379:6379 -p 8001:8001 redis/redis-stack:latest\n</code></pre> <pre><code>podman run -d --rm --name redis -p 6379:6379 -p 8001:8001 redis/redis-stack:latest\n</code></pre> <p>You may check messages are incoming through the web interface on <code>http://localhost:8001</code> or with a redis CLI client, for instance:</p> <pre><code>$ uvx iredis\nInstalled 11 packages in 51ms\niredis  1.15.0 (Python 3.13.1)\nredis-server  7.4.1\nHome:   https://iredis.xbin.io/\nIssues: https://github.com/laixintao/iredis/issues\n127.0.0.1:6379&gt; psubscribe jet1090\n# messages should be incoming here\n</code></pre>"},{"location":"sources/","title":"Sources of data","text":"<p><code>jet1090</code> decodes feeds of Mode S messages coming from a variety of sources.</p>"},{"location":"sources/#rtl-sdr-dongles","title":"RTL-SDR dongles","text":"<p>The most common source is the RTL-SDR dongle.</p> <p></p> <p><code>jet1090</code> must be compiled with the <code>rtlsdr</code> feature in order to support RTL-SDR dongles.</p> <p>You can check whether <code>jet1090</code> detects your dongle:</p> <pre><code>$ jet1090 --discover=rtlsdr\nDetached kernel driver\nFound Rafael Micro R820T tuner\nReattached kernel driver\n[INFO] Opening Generic RTL2832U OEM :: 00000001...\nDetached kernel driver\nFound Rafael Micro R820T tuner\nReattached kernel driver\n</code></pre> <p>You can then start decoding incoming messages. Use the <code>--verbose</code> option to check it is working well.</p> <pre><code>$ jet1090 --verbose rtlsdr://\nFound Rafael Micro R820T tuner\n[INFO] Opening Generic RTL2832U OEM :: 00000001...\nFound Rafael Micro R820T tuner\n[INFO] Using format CS16.\nAllocating 15 zero-copy buffers\n\n{\"timestamp\":1735082050.8826132,\"frame\":\"8d34768d58b524b5986843dfee26\",\"df\":\"17\",\"icao24\":\"34768d\",\"bds\":\"05\",\"tc\":11,\"NUCp\":7,\"NICb\":0,\"altitude\":35050,\"source\":\"barometric\",\"parity\":\"odd\",\"lat_cpr\":23244,\"lon_cpr\":26691,\"metadata\":[{\"system_timestamp\":1735082050.8826132,\"rssi\":-28.450745,\"serial\":14924845721654670821,\"name\":\"rtlsdr\"}]}\n{\"timestamp\":1735082051.040175,\"frame\":\"8d34768de11200000000002919db\",\"df\":\"17\",\"icao24\":\"34768d\",\"bds\":\"61\",\"subtype\":\"emergency_priority\",\"emergency_state\":\"none\",\"squawk\":\"2010\",\"metadata\":[{\"system_timestamp\":1735082051.040175,\"rssi\":-29.93521,\"serial\":14924845721654670821,\"name\":\"rtlsdr\"}]}\n</code></pre> <p>Tip</p> <p>It is recommended to specify a reference location in order to decode ground messages as well.</p> <p>You may use four-letter airport codes, three-letter airport codes, or latitude and longitude values separated by a comma.</p> <pre><code>jet1090 --verbose rtlsdr://@EHAM  # Amsterdam Schiphol airport (NL)\njet1090 --verbose rtlsdr://@LHR  # London Heathrow airport (UK)\n</code></pre> <p>Tip</p> <p>By default, all dongles seem to have the same serial number <code>00000001</code>.</p> <p>If you want to give a different serial number to one of them, you may use the <code>rtl_eeprom</code> program:</p> <pre><code>rtl_eeprom -d 0 -s 00000002\n</code></pre> <p>If you have several dongles attached to different antennas, you may specify which one to select based on their serial number. That information will appear in the <code>\"name\"</code> field in the metadata:</p> <pre><code>jet1090 rtlsdr://serial=00000001 rtlsdr://serial=00000002\n</code></pre>"},{"location":"sources/#beast-format","title":"Beast format","text":""},{"location":"sources/#tcp","title":"TCP","text":"<p>Most decoders share the data they decode in the Beast binary format which contains timestamp information, signal level information (rssi) and Mode S short or long messages.</p> <ul> <li>dump1090 sends the data from the 30005 port;</li> <li>Radarcape and Air!Squitter receivers (by jetvision) send their CRC pre-checked raw data from the 10003 port.</li> </ul> <p>You can decode that data with the following command:</p> <pre><code>jet1090 --verbose tcp://192.168.0.20:10003\n</code></pre> <p>You can add more receivers to the command:</p> <pre><code>jet1090 --verbose tcp://192.168.0.20:10003@LFBO tcp://192.168.0.30:10003@LFPO\n</code></pre>"},{"location":"sources/#udp","title":"UDP","text":"<p>When receivers are not accessible by the client for network configuration reasons, it is common practice to redirect the Beast feed to a UDP endpoint on another IP address. There is a dedicated setting on Radarcape devices for that. Otherwise, you can use <code>socat</code> to redirect the TCP output to an external UDP endpoint:</p> <pre><code>socat TCP:localhost:30005 UDP-DATAGRAM:1.2.3.4:5678\n</code></pre> <p>You can run <code>jet1090</code> on that remote machine:</p> <pre><code>jet1090 --verbose udp://:5678\n</code></pre> <p>Warning</p> <p>In UDP, only one program can listen to a specific port at a time. If you need multiple instances of a program to receive the same data feed, you can use the following WebSocket solution with tools like <code>wsbroad</code> and <code>websocat</code>.</p>"},{"location":"sources/#websocket","title":"WebSocket","text":"<p>The following settings helps to centralize several UDP feeds on one machine, and redistribute them.</p> <p>First run the <code>wsbroad</code> command:</p> <pre><code>wsbroad 0.0.0.0:9876\n</code></pre> <p>Then redirect the UDP feed to a WebSocket endpoint:</p> <pre><code>websocat -b -u udp-l:127.0.0.1:5678 ws://0.0.0.0:9876/5678\n</code></pre> <p>You may then check data is coming:</p> <pre><code>websocat ws://localhost:9876/5678\n</code></pre> <p>Tip</p> <p>You may create some services for managing these connexions more easily. Copy the service files to <code>.config/systemd/user</code> then:</p> <pre><code>systemctl --user start wsbroad\nsystemctl --user start websocat@5678\n</code></pre> <p>You can have a <code>websocat@.service</code> file as such:</p> <pre><code>[Unit]\nDescription=Redirect UDP %i streaming to WebSocket\n\n[Service]\nType=simple\nExecStart=/home/user/.local/bin/websocat -b -u udp-l:0.0.0.0:%i ws://0.0.0.0:9876/%i\nRestartSec=3\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>and a <code>wsbroad.service</code> as:</p> <pre><code>[Unit]\nDescription=WebSocket broadcast at 9876\n\n[Service]\nType=simple\nExecStart=/home/user/.local/bin/wsbroad 0.0.0.0:9876\nRestart=always\nRestartSec=3\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"sources/#sero-systems-api","title":"SeRo Systems API","text":"<p>If you have a token for the SeRo Systems API, include it in your configuration file with the <code>sero.token</code> entry.</p>"}]}